---
title: "The ```mvp``` package: fast multivariate polynomials R"
author: "Robin K. S. Hankin"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{mvp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r set-options, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", dev = "png", fig.width = 7, fig.height = 3.5, message = FALSE, warning = FALSE)
options(width = 80, tibble.width = Inf)
```

# Introduction

The ```mvp``` package provides some functionality for fast
manipulation of multivariate polynomials, using the Standard Template
library of ```C++```, commonly known as the ```STL```.  The package is
comparable in speed to the ```spray``` package for sparse arrays,
while retaining the symbolic capabilities of the ```mpoly``` package.
It uses the excellent print and coercion methods of ```mpoly```; the
only improvement of this package on ```mpoly``` is its speed, and the
ability to handle negative powers.

# The ```STL map``` class

A ```map``` is a sorted associative container that contains key-value
pairs with unique keys.  It is interesting here because search and
insertion operations have logarithmic complexity.  Multivariate
polynomials are considered to be the sum of a finite number of
*terms*, each multiplied by a coefficient.  A *term* is something like
$x^2y^3z$.  We may consider this term to be the map

```
{"x" -> 2, "y" -> 3, "z" -> 7}
```

the map takes symbols to their (integer) power, and it is understood
that powers are nonzero.  A ```mvp``` object is a map from terms to
their coeffients; thus $7xy^2 -3x^2z^5$ would be

```
{{"x" -> 2, "y" -> 3, "z" -> 1} -> 7, {"x" -> 2, "z" ->5} -> -7
```  

and we understand that coefficients are nonzero.  In ```C++``` the
declarations would be

```
typedef vector <signed int> mypowers;  
typedef vector <string> mynames;  

typedef map <string, signed int> term; 
typedef map <term, double> mvp; 
```

Thus a ```term``` maps a string to a (signed) integer, and a ```mvp```
maps terms to doubles. 

One reason why the ```map``` class is fast is that the order in which
the keys are stored is undefined: the compiler may store them in the
order which it regards as most propitious.  This is not an issue for
the maps considered here as addition and multiplication are
commutative and associative.

Note also that constant terms are handled with no difficulty
(constants are simply maps from the empty map to its value), as is the
zero polynomial (which is simply an empty map).

## The package in use

Consider a simple multivariate polynomial:


```{r}
library("mvp",quietly=TRUE)
p <- as.mvp("3x y + z^3 + x y^6 z")
p
```

Coercion and printing are accomplished by the ```mpoly``` package.
Note, however, that the order of the terms is not preserved, and
neither is the order of the symbols within a single term.  Although
this might sound odd, if we consider a marginally more involved
situation, such as

```{r}
M <- as.mvp("3 stoat*goat^6 -4 + 7 boat^3 * bloat -9 float*boat*goat*gloat^6")
M
```

it is not clear that any human-discernable ordering is preferable to
any other, and we would be better off letting the compiler decide a
propitious ordering.  In any event, the ```mpoly``` package can
specify a print order:


```{r}
print(M,order="lex", varorder=c("stoat","goat","boat","bloat","gloat","float"))
```


## Arithmetic operations

The arithmetic operations ```*```, ```+```, ```-``` and ```^``` work
as expected:

```{r}
S1 <- rmvp(5,2,2,4)
S2 <- rmvp(5,2,2,4)
S1
S2
S1+S2
S1*S2
S1^2
```

## Substitution

The package has two substitution functionalities.  Firstly, we can
substitute one or more variables for a numeric value.  Define a mvp
object:

```{r}
S3 <- as.mvp("x + 5x^4*y + 8y^2*x*z^3")
S3
```

And then we may substitute $x=1$:

```{r}
subs(S3,x=1)
```

Note the natural R idiom, and that the return value is another mvp
object.  We may subsitute for the other variables:

```{r}
subs(S3,x=1,y=2,z=3)
```

(in this case, the default behaviour is to return a "dropped" version
of the resulting polynomial, that is, coerced to a scalar).  The other
mode of substitution is to replace a variable by another polynomial:

```{r}
subsmvp(S3,"z",as.mvp("a^2+2b^3"))
```

## Differentiation

Differentiation is implemented.  First we have the ```deriv()```
method:

```{r}
S <- rmvp(5,4,3,4)
S
deriv(S,letters[1:3])
deriv(S,rev(letters[1:3]))  # should be the same.
```

Also a slightly different form:```aderiv()```, here used to evaluate
$\frac{\partial^6S}{\partial a^3\partial b\partial c^2}$:

```{r}
aderiv(S,c(a=3,b=1,c=2))
```

## Some timings

```{r}
library("spray")
library("mpoly")
a1 <- rmvp(30,9,9,26)
a2 <- as.mpoly(a1)
a3 <- mvp_to_spray(a1)
system.time(ignore <- a1^3)  # mvp
system.time(ignore <- a2^3)  # mpoly
system.time(ignore <- a3^3)  # spray
```

